<!-- problem:start -->

# [3408. Design Task Manager](https://leetcode.com/problems/design-task-manager)

## Description

<!-- description:start -->

<p>There is a task management system that allows users to manage their tasks, each associated with a priority. The system should efficiently handle adding, modifying, executing, and removing tasks.</p>

<p>Implement the <code>TaskManager</code> class:</p>

<ul>
	<li>
    <p><code>TaskManager(vector&lt;vector&lt;int&gt;&gt;&amp; tasks)</code> initializes the task manager with a list of user-task-priority triples. Each element in the input list is of the form <code>[userId, taskId, priority]</code>, which adds a task to the specified user with the given priority.</p>
    </li>
    <li>
    <p><code>void add(int userId, int taskId, int priority)</code> adds a task with the specified <code>taskId</code> and <code>priority</code> to the user with <code>userId</code>. It is <strong>guaranteed</strong> that <code>taskId</code> does not <em>exist</em> in the system.</p>
    </li>
    <li>
    <p><code>void edit(int taskId, int newPriority)</code> updates the priority of the existing <code>taskId</code> to <code>newPriority</code>. It is <strong>guaranteed</strong> that <code>taskId</code> <em>exists</em> in the system.</p>
    </li>
    <li>
    <p><code>void rmv(int taskId)</code> removes the task identified by <code>taskId</code> from the system. It is <strong>guaranteed</strong> that <code>taskId</code> <em>exists</em> in the system.</p>
    </li>
    <li>
    <p><code>int execTop()</code> executes the task with the <strong>highest</strong> priority across all users. If there are multiple tasks with the same <strong>highest</strong> priority, execute the one with the highest <code>taskId</code>. After executing, the<strong> </strong><code>taskId</code><strong> </strong>is <strong>removed</strong> from the system. Return the <code>userId</code> associated with the executed task. If no tasks are available, return -1.</p>
    </li>
</ul>

<p><strong>Note</strong> that a user may be assigned multiple tasks.</p>
<p>&nbsp;</p>

<p><strong class="example">Example 1:</strong></p>
<div class="example-block">
<p><strong>Input:</strong><br />
<span class="example-io">[&quot;TaskManager&quot;, &quot;add&quot;, &quot;edit&quot;, &quot;execTop&quot;, &quot;rmv&quot;, &quot;add&quot;, &quot;execTop&quot;]<br />
[[[[1, 101, 10], [2, 102, 20], [3, 103, 15]]], [4, 104, 5], [102, 8], [], [101], [5, 105, 15], []]</span></p>
<p><strong>Output:</strong><br />
<span class="example-io">[null, null, null, 3, null, null, 5] </span></p>
<p><strong>Explanation</strong></p>
TaskManager taskManager = new TaskManager([[1, 101, 10], [2, 102, 20], [3, 103, 15]]); // Initializes with three tasks for Users 1, 2, and 3.<br />
taskManager.add(4, 104, 5); // Adds task 104 with priority 5 for User 4.<br />
taskManager.edit(102, 8); // Updates priority of task 102 to 8.<br />
taskManager.execTop(); // return 3. Executes task 103 for User 3.<br />
taskManager.rmv(101); // Removes task 101 from the system.<br />
taskManager.add(5, 105, 15); // Adds task 105 with priority 15 for User 5.<br />
taskManager.execTop(); // return 5. Executes task 105 for User 5.</div>
<p>&nbsp;</p>

<p><strong>Constraints:</strong></p>
<ul>
    <li><code>1 &lt;= tasks.length &lt;= 10<sup>5</sup></code></li>
    <li><code>0 &lt;= userId &lt;= 10<sup>5</sup></code></li>
    <li><code>0 &lt;= taskId &lt;= 10<sup>5</sup></code></li>
    <li><code>0 &lt;= priority &lt;= 10<sup>9</sup></code></li>
    <li><code>0 &lt;= newPriority &lt;= 10<sup>9</sup></code></li>
    <li>At most <code>2 * 10<sup>5</sup></code> calls will be made in <strong>total</strong> to <code>add</code>, <code>edit</code>, <code>rmv</code>, and <code>execTop</code> methods.</li>
    <li>The input is generated such that <code>taskId</code> will be valid.</li>
</ul>
<p>&nbsp;</p>

<!-- description:end -->

## Solutions

<!-- solution:start -->

### **Approach 1: Hash Map or Ordered Set**

We use a hash map $\text{taskMap}$ to store task information, where the key is the task ID and the value is a tuple $(\text{userId}, \text{taskId}, \text{priority})$ representing the user ID, task ID and the priority of the task.

We use an ordered set $\text{taskSet}$ to store all tasks currently in the system, where each element is a tuple $(\text{userId}, \text{taskId}, \text{priority})$ representing the user ID, task ID and priority respectively of the task.

For each operation, we can process as follows:

-   **Initialization**: For each task $(\text{userId}, \text{taskId}, \text{priority})$, add it to the hash map $\text{taskMap}$ and the ordered set $\text{taskSet}$.
-   **Add Task**: Add the task $(\text{userId}, \text{taskId}, \text{priority})$ to the hash map $\text{taskMap}$ and the ordered set $\text{taskSet}$.
-   **Edit Task**: Retrieve the user ID and old priority for the given task ID from the hash map $\text{taskMap}$, remove the old task information from the ordered set $\text{taskSet}$, then add the new task information to both the hash map and the ordered set.
-   **Remove Task**: Retrieve the priority for the given task ID from the hash map $\text{taskMap}$, remove the task information from the ordered set $\text{taskSet}$, and delete the task from the hash map.
-   **Execute Top Priority Task**: If the ordered set $\text{taskSet}$ is empty, return -1. Otherwise, take the first element from the ordered set, get the task ID, retrieve the corresponding user ID from the hash map, and remove the task from both the hash map and the ordered set. Finally, return the user ID.

For time complexity, initialization requires $O(n \log n)$ time, where $n$ is the number of initial tasks. Each add, edit, remove, and execute operation requires $O(\log m)$ time, where $m$ is the current number of tasks in the system. Since the total number of operations does not exceed $2 \times 10^5$, the overall time complexity is acceptable. The space complexity is $O(n + m)$ for storing the hash map and ordered set.

<p><strong>Time Complexity:</strong></p>
<p><strong>Space Complexity:</strong> $O(n + m)$</p>

<!-- tabs:start -->

```java
class TaskManager {
    public Map<Integer, int[]> taskMap = new HashMap<>();
    public TreeSet<int[]> taskSet = new TreeSet<>((a, b) -> {
        return (a[2] == b[2]) ? b[1] - a[1] : b[2] - a[2];
    });
    
    public TaskManager(List<List<Integer>> tasks) {
        for (List<Integer> task : tasks) {
            add(task.get(0), task.get(1), task.get(2));
        }
    }
    
    public void add(int userId, int taskId, int priority) {
        taskMap.put(taskId, new int[]{userId, priority});
        taskSet.add(new int[]{userId, taskId, priority});
    }
    
    public void edit(int taskId, int newPriority) {
        int[] task = taskMap.get(taskId);
        int userId = task[0], priority = task[1];
        taskSet.remove(new int[]{userId, taskId, priority});
        
        taskMap.put(taskId, new int[]{userId, newPriority});
        taskSet.add(new int[]{userId, taskId, newPriority});
    }
    
    public void rmv(int taskId) {
        int[] task = taskMap.remove(taskId);
        int userId = task[0], priority = task[1];
        taskSet.remove(new int[]{userId, taskId, priority});
    }
    
    public int execTop() {
        if (taskSet.isEmpty()) {
            return -1;
        }
        
        int[] topTask = taskSet.pollFirst();
        int[] task = taskMap.remove(topTask[1]);
        return task[0];
    }
}

/**
 * Your TaskManager object will be instantiated and called as such:
 * TaskManager obj = new TaskManager(tasks);
 * obj.add(userId,taskId,priority);
 * obj.edit(taskId,newPriority);
 * obj.rmv(taskId);
 * int param_4 = obj.execTop();
 */
```

<!-- tabs:end -->

<!-- solution:end -->

<!-- problem:end -->