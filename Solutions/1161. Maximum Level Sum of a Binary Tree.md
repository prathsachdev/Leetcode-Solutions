<!-- problem:start -->

# [1161. Maximum Level Sum of a Binary Tree](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree)

## Description

<!-- description:start -->

<p>Given the <code>root</code> of a binary tree, the level of its root is <code>1</code>, the level of its children is <code>2</code>, and so on.</p>

<p>Return the <strong>smallest</strong> level <code>x</code> such that the sum of all the values of nodes at level <code>x</code> is <strong>maximal</strong>.</p>
<p>&nbsp;</p>

<p><strong class="example">Example 1:</strong></p>
<img alt="" src="https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1100-1199/1161.Maximum%20Level%20Sum%20of%20a%20Binary%20Tree/images/capture.jpg" style="width: 200px; height: 175px;" />
<pre>
<strong>Input:</strong> root = [1,7,0,7,-8,null,null]
<strong>Output:</strong> 2
<strong>Explanation: </strong>
Level 1 sum = 1.
Level 2 sum = 7 + 0 = 7.
Level 3 sum = 7 + -8 = -1.
So we return the level with the maximum sum which is level 2.
</pre>

<p><strong class="example">Example 2:</strong></p>
<pre>
<strong>Input:</strong> root = [989,null,10250,98693,-89388,null,null,null,-32127]
<strong>Output:</strong> 2
</pre>
<p>&nbsp;</p>

<p><strong>Constraints:</strong></p>
<ul>
    <li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>
    <li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>
<p>&nbsp;</p>

<!-- description:end -->

## Solutions

<!-- solution:start -->

### **Approach 1: BFS**

We use BFS to traverse level by level, calculating the sum of nodes at each level, and find the level with the maximum sum. If there are multiple levels with the maximum sum, return the smallest level number.

Specifically, we use a queue $q$ to store the nodes of the current level. During each traversal, we record the sum of nodes at the current level as $sum$, then add all child nodes of the current level to the queue to prepare for the next level. We use variable $maxSum$ to record the current maximum sum, and variable $ans$ to record the corresponding level number. After calculating the sum of each level, if $sum$ is greater than $maxSum$, we update $maxSum$ and $ans$. Finally, we return $ans$.

The time complexity is $O(n)$ and the space complexity is $O(n)$, where $n$ is the number of nodes in the binary tree.

<p><strong>Time Complexity:</strong> $O(n)$</p>
<p><strong>Space Complexity:</strong> $O(n)$</p>

<!-- tabs:start -->

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxLevelSum(TreeNode root) {
        Deque<TreeNode> q = new ArrayDeque<>();
        q.offer(root);
        
        int maxSum = Integer.MIN_VALUE;
        int lvl = 0;
        int ans = 0;
        
        while(!q.isEmpty()) {
            ++lvl;
            int sum = 0;
            
            for (int i = q.size(); i > 0; --i) {
                TreeNode node = q.pollFirst();
                
                sum += node.val;
                
                if (node.left != null) {
                    q.offer(node.left);
                }
                
                if (node.right != null) {
                    q.offer(node.right);
                }
            }
            
            if (maxSum < sum) {
                maxSum = sum;
                ans = lvl;
            }
        }
        
        return ans;
    }
}
```

<!-- tabs:end -->

<!-- solution:end -->

<!-- problem:end -->